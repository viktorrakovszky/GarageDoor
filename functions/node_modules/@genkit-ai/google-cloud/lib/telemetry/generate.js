"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var generate_exports = {};
__export(generate_exports, {
  generateTelemetry: () => generateTelemetry
});
module.exports = __toCommonJS(generate_exports);
var import_core = require("@genkit-ai/core");
var import_logging = require("@genkit-ai/core/logging");
var import_tracing = require("@genkit-ai/core/tracing");
var import_api = require("@opentelemetry/api");
var import_crypto = require("crypto");
var import_metrics = require("../metrics");
var import_truncate_utf8_bytes = __toESM(require("truncate-utf8-bytes"));
var import_utils = require("../utils");
class GenerateTelemetry {
  constructor() {
    /**
     * Wraps the declared metrics in a Genkit-specific, internal namespace.
     */
    this._N = import_metrics.internalMetricNamespaceWrap.bind(null, "ai");
    /** The maximum length (in bytes) of a logged prompt message. The maximum log
     * size in GCP is 256kb, so using slightly lower for some buffer for the rest
     * of the message*/
    this.MAX_LOG_CONTENT_BYTES = 2e5;
    this.actionCounter = new import_metrics.MetricCounter(this._N("generate/requests"), {
      description: "Counts calls to genkit generate actions.",
      valueType: import_api.ValueType.INT
    });
    this.latencies = new import_metrics.MetricHistogram(this._N("generate/latency"), {
      description: "Latencies when interacting with a Genkit model.",
      valueType: import_api.ValueType.DOUBLE,
      unit: "ms"
    });
    this.inputCharacters = new import_metrics.MetricCounter(
      this._N("generate/input/characters"),
      {
        description: "Counts input characters to any Genkit model.",
        valueType: import_api.ValueType.INT
      }
    );
    this.inputTokens = new import_metrics.MetricCounter(this._N("generate/input/tokens"), {
      description: "Counts input tokens to a Genkit model.",
      valueType: import_api.ValueType.INT
    });
    this.inputImages = new import_metrics.MetricCounter(this._N("generate/input/images"), {
      description: "Counts input images to a Genkit model.",
      valueType: import_api.ValueType.INT
    });
    this.inputVideos = new import_metrics.MetricCounter(this._N("generate/input/videos"), {
      description: "Counts input videos to a Genkit model.",
      valueType: import_api.ValueType.INT
    });
    this.inputAudio = new import_metrics.MetricCounter(this._N("generate/input/audio"), {
      description: "Counts input audio files to a Genkit model.",
      valueType: import_api.ValueType.INT
    });
    this.outputCharacters = new import_metrics.MetricCounter(
      this._N("generate/output/characters"),
      {
        description: "Counts output characters from a Genkit model.",
        valueType: import_api.ValueType.INT
      }
    );
    this.outputTokens = new import_metrics.MetricCounter(this._N("generate/output/tokens"), {
      description: "Counts output tokens from a Genkit model.",
      valueType: import_api.ValueType.INT
    });
    this.outputImages = new import_metrics.MetricCounter(this._N("generate/output/images"), {
      description: "Count output images from a Genkit model.",
      valueType: import_api.ValueType.INT
    });
    this.outputVideos = new import_metrics.MetricCounter(this._N("generate/output/videos"), {
      description: "Count output videos from a Genkit model.",
      valueType: import_api.ValueType.INT
    });
    this.outputAudio = new import_metrics.MetricCounter(this._N("generate/output/audio"), {
      description: "Count output audio files from a Genkit model.",
      valueType: import_api.ValueType.INT
    });
  }
  tick(span, paths, logIO, projectId) {
    const attributes = span.attributes;
    const modelName = attributes["genkit:name"];
    const path = attributes["genkit:path"] || "";
    const input = "genkit:input" in attributes ? JSON.parse(
      attributes["genkit:input"]
    ) : void 0;
    const output = "genkit:output" in attributes ? JSON.parse(
      attributes["genkit:output"]
    ) : void 0;
    const errName = (0, import_utils.extractErrorName)(span.events);
    const flowName = (0, import_utils.extractOuterFlowNameFromPath)(path);
    if (input) {
      this.recordGenerateActionMetrics(modelName, flowName, path, input, {
        response: output,
        errName
      });
      this.recordGenerateActionConfigLogs(
        span,
        modelName,
        flowName,
        path,
        input,
        projectId
      );
      if (logIO) {
        this.recordGenerateActionInputLogs(
          span,
          modelName,
          flowName,
          path,
          input,
          projectId
        );
      }
    }
    if (output && logIO) {
      this.recordGenerateActionOutputLogs(
        span,
        modelName,
        flowName,
        path,
        output,
        projectId
      );
    }
  }
  recordGenerateActionMetrics(modelName, flowName, path, input, opts) {
    var _a, _b, _c, _d, _e, _f;
    this.doRecordGenerateActionMetrics(modelName, ((_a = opts.response) == null ? void 0 : _a.usage) || {}, {
      temperature: (_b = input.config) == null ? void 0 : _b.temperature,
      topK: (_c = input.config) == null ? void 0 : _c.topK,
      topP: (_d = input.config) == null ? void 0 : _d.topP,
      maxOutputTokens: (_e = input.config) == null ? void 0 : _e.maxOutputTokens,
      flowName,
      path,
      latencyMs: (_f = opts.response) == null ? void 0 : _f.latencyMs,
      errName: opts.errName,
      source: "ts",
      sourceVersion: import_core.GENKIT_VERSION
    });
  }
  recordGenerateActionConfigLogs(span, model, flowName, qualifiedPath, input, projectId) {
    var _a, _b, _c, _d, _e;
    const path = (0, import_tracing.toDisplayPath)(qualifiedPath);
    const sharedMetadata = __spreadProps(__spreadValues({}, (0, import_utils.createCommonLogAttributes)(span, projectId)), {
      model,
      path,
      qualifiedPath,
      flowName
    });
    import_logging.logger.logStructured(`Config[${path}, ${model}]`, __spreadProps(__spreadValues({}, sharedMetadata), {
      temperature: (_a = input.config) == null ? void 0 : _a.temperature,
      topK: (_b = input.config) == null ? void 0 : _b.topK,
      topP: (_c = input.config) == null ? void 0 : _c.topP,
      maxOutputTokens: (_d = input.config) == null ? void 0 : _d.maxOutputTokens,
      stopSequences: (_e = input.config) == null ? void 0 : _e.stopSequences,
      source: "ts",
      sourceVersion: import_core.GENKIT_VERSION
    }));
  }
  recordGenerateActionInputLogs(span, model, flowName, qualifiedPath, input, projectId) {
    const path = (0, import_tracing.toDisplayPath)(qualifiedPath);
    const sharedMetadata = __spreadProps(__spreadValues({}, (0, import_utils.createCommonLogAttributes)(span, projectId)), {
      model,
      path,
      qualifiedPath,
      flowName
    });
    const messages = input.messages.length;
    input.messages.forEach((msg, msgIdx) => {
      const parts = msg.content.length;
      msg.content.forEach((part, partIdx) => {
        const partCounts = this.toPartCounts(partIdx, parts, msgIdx, messages);
        import_logging.logger.logStructured(`Input[${path}, ${model}] ${partCounts}`, __spreadProps(__spreadValues({}, sharedMetadata), {
          content: this.toPartLogContent(part),
          partIndex: partIdx,
          totalParts: parts,
          messageIndex: msgIdx,
          totalMessages: messages
        }));
      });
    });
  }
  recordGenerateActionOutputLogs(span, model, flowName, qualifiedPath, output, projectId) {
    const path = (0, import_tracing.toDisplayPath)(qualifiedPath);
    const sharedMetadata = __spreadProps(__spreadValues({}, (0, import_utils.createCommonLogAttributes)(span, projectId)), {
      model,
      path,
      qualifiedPath,
      flowName
    });
    const candidates = output.candidates.length;
    output.candidates.forEach((cand, candIdx) => {
      const parts = cand.message.content.length;
      const candCounts = parts > 1 ? ` (${candIdx + 1} of ${parts})` : "";
      import_logging.logger.logStructured(`Output Candidate[${path}, ${model}]${candCounts}`, __spreadProps(__spreadValues({}, sharedMetadata), {
        candidateIndex: candIdx,
        totalCandidates: candidates,
        messageIndex: cand.index,
        finishReason: cand.finishReason,
        finishMessage: cand.finishMessage,
        role: cand.message.role,
        usage: cand.usage,
        custom: cand.custom
      }));
      cand.message.content.forEach((part, partIdx) => {
        const partCounts = this.toPartCounts(
          partIdx,
          parts,
          candIdx,
          candidates
        );
        const initial = cand.finishMessage ? { finishMessage: this.toPartLogText(cand.finishMessage) } : {};
        import_logging.logger.logStructured(`Output[${path}, ${model}] ${partCounts}`, __spreadProps(__spreadValues(__spreadValues({}, initial), sharedMetadata), {
          content: this.toPartLogContent(part),
          partIndex: partIdx,
          totalParts: parts,
          candidateIndex: candIdx,
          totalCandidates: candidates,
          messageIndex: cand.index,
          finishReason: cand.finishReason
        }));
      });
      if (output.usage) {
        import_logging.logger.logStructured(`Usage[${path}, ${model}]`, __spreadProps(__spreadValues({}, sharedMetadata), {
          usage: output.usage
        }));
      }
    });
  }
  toPartCounts(partOrdinal, parts, msgOrdinal, messages) {
    if (parts > 1 && messages > 1) {
      return `(part ${this.xOfY(partOrdinal, parts)} in message ${this.xOfY(
        msgOrdinal,
        messages
      )})`;
    }
    if (parts > 1) {
      return `(part ${this.xOfY(partOrdinal, parts)})`;
    }
    if (messages > 1) {
      return `(message ${this.xOfY(msgOrdinal, messages)})`;
    }
    return "";
  }
  xOfY(x, y) {
    return `${x} of ${y}`;
  }
  toPartLogContent(part) {
    if (part.text) {
      return this.toPartLogText(part.text);
    }
    if (part.media) {
      return this.toPartLogMedia(part);
    }
    if (part.toolRequest) {
      return this.toPartLogToolRequest(part);
    }
    if (part.toolResponse) {
      return this.toPartLogToolResponse(part);
    }
    return "<unknown format>";
  }
  toPartLogText(text) {
    return (0, import_truncate_utf8_bytes.default)(text, this.MAX_LOG_CONTENT_BYTES);
  }
  toPartLogMedia(part) {
    if (part.media.url.startsWith("data:")) {
      const splitIdx = part.media.url.indexOf("base64,");
      if (splitIdx < 0) {
        return "<unknown media format>";
      }
      const prefix = part.media.url.substring(0, splitIdx + 7);
      const hashedContent = (0, import_crypto.createHash)("sha256").update(part.media.url.substring(splitIdx + 7)).digest("hex");
      return `${prefix}<sha256(${hashedContent})>`;
    }
    return this.toPartLogText(part.media.url);
  }
  toPartLogToolRequest(part) {
    const inputText = typeof part.toolRequest.input === "string" ? part.toolRequest.input : JSON.stringify(part.toolRequest.input);
    return this.toPartLogText(
      `Tool request: ${part.toolRequest.name}, ref: ${part.toolRequest.ref}, input: ${inputText}`
    );
  }
  toPartLogToolResponse(part) {
    const outputText = typeof part.toolResponse.output === "string" ? part.toolResponse.output : JSON.stringify(part.toolResponse.output);
    return this.toPartLogText(
      `Tool response: ${part.toolResponse.name}, ref: ${part.toolResponse.ref}, output: ${outputText}`
    );
  }
  /**
   * Records all metrics associated with performing a GenerateAction.
   */
  doRecordGenerateActionMetrics(modelName, usage, dimensions) {
    const shared = {
      modelName,
      flowName: dimensions.flowName,
      path: dimensions.path,
      temperature: dimensions.temperature,
      topK: dimensions.topK,
      topP: dimensions.topP,
      source: dimensions.source,
      sourceVersion: dimensions.sourceVersion,
      status: dimensions.errName ? "failure" : "success"
    };
    this.actionCounter.add(1, __spreadValues({
      maxOutputTokens: dimensions.maxOutputTokens,
      error: dimensions.errName
    }, shared));
    this.latencies.record(dimensions.latencyMs, shared);
    this.inputTokens.add(usage.inputTokens, shared);
    this.inputCharacters.add(usage.inputCharacters, shared);
    this.inputImages.add(usage.inputImages, shared);
    this.inputVideos.add(usage.inputVideos, shared);
    this.inputAudio.add(usage.inputAudioFiles, shared);
    this.outputTokens.add(usage.outputTokens, shared);
    this.outputCharacters.add(usage.outputCharacters, shared);
    this.outputImages.add(usage.outputImages, shared);
    this.outputVideos.add(usage.outputVideos, shared);
    this.outputAudio.add(usage.outputAudioFiles, shared);
  }
}
const generateTelemetry = new GenerateTelemetry();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  generateTelemetry
});
//# sourceMappingURL=generate.js.map